# 对话式销售日志录入系统

## 详细设计说明书（V3）

---

## 1. 文档目的与适用范围

### 1.1 文档目的

本文档用于说明 **对话式销售日志录入系统** 的完整详细设计与技术实现方案，明确：

- 系统业务功能与边界
- 对话与状态模型的唯一事实来源
- 规则驱动的状态推导机制
- LLM 的职责与使用限制
- 程序核心逻辑流转
- 数据模型与持久化策略
- 并发、异常与恢复机制

**本文档可直接作为开发、测试、架构评审的依据，不依赖额外口头说明。**

---

### 1.2 适用范围

适用于：

- 后端工程师
- 架构师
- LLM 接入工程师
- 测试工程师
- 技术负责人

---

## 2. 系统设计目标与强约束

### 2.1 设计目标

构建一个支持自然语言、多轮对话的销售日志录入系统，满足：

- 支持口语化、非结构化、跑题输入
- 单一会话中支持 **多个客户并行跟进**
- 系统以自然对话连续性作为第一优先级目标
- 任何状态收集、字段写入，均是对话过程的副产物，而非对话的前置条件
- 系统不得因为状态不完整、语义失败而中断或重置对话流程
- LLM 仅用于：
  - 自然语言生成
  - 语义理解与信息提取
- 本系统允许并主动设计“语义失败但对话成功”的运行路径。
  - 在任何语义不确定或技术异常场景下，系统优先保障对话连续性与用户体验；
  - 同时通过严格的写入控制，确保业务状态始终可信、可回放、可恢复。

---

### 2.2 核心强约束（不可违反）

1. **结构化状态是唯一可信事实**
2. 所有状态变化必须由 **规则引擎推导**
3. LLM 不得直接修改业务状态
4. 不确定信息不得写入
5. 跑题、情绪输入视为正常输入路径

---

## 3. 系统业务功能说明

### 3.1 会话级销售日志管理

- 通过飞书机器人进行对话式销售日志录入
- 一个 Session 对应一次持续性的对话上下文，可在多次中断、恢复中逐步完成一个或多个客户的跟进记录。
- 支持：
  - 多轮输入
  - 中断与恢复
  - 显式确认
  - 明确结束

---

### 3.2 多客户并行跟进能力

- 单 Session 内支持多个客户
- 每个客户：
  - 独立的数据字段
  - 独立的完成状态
- 系统在任意时刻只聚焦一个客户（focus_customer）

---

### 3.3 销售跟进要素定义

每个客户需采集以下字段：


| 字段             | 说明                | 是否必填 |
| -------------- | ----------------- | ---- |
| customer_name  | 客户名称              | 是    |
| follow_time    | 跟进时间              | 是    |
| contact_person | 联系人（姓名 / 职务 / 电话） | 否    |
| follow_method  | 跟进方式              | 是    |
| follow_content | 跟进事项 / 项目         | 是    |
| follow_goal    | 本次目标              | 是    |
| follow_result  | 本次结果              | 是    |
| risk           | 风险 / 阻塞点          | 否    |
| next_plan      | 下一步计划             | 是    |


**所有字段必须来自用户明确表达，不允许系统或模型推断补全。**

- follow_time： 
  - 本次客户跟进所对应的时间点。
  - 若用户在对话中明确提及具体时间（如“上午”“昨天”“2 点左右”），则以用户表达为准；
  - 若用户未明确提及，则在对话完成并确认阶段，由系统以该客户首次进入对话聚焦时的会话时间作为 follow_time。
  - follow_time 的确定 不得影响对话过程推进，仅在输出业务结果时补齐。

---

## 4. 系统总体架构

### 4.1 架构图

```
┌──────────────────────────────────────────────┐
│              飞书 客户端                      │
│        （自然语言输入 / 回复展示）             │
└──────────────────────┬───────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────┐
│          Bot Adapter（接入层）                │
│  - 飞书消息接收 / 发送                         │
│  - user_id / session_id 识别                  │
│  - 幂等校验                                   │
│                                              │
│  ※ 不做任何状态判断                           │
│  ※ 不参与提示词选择                           │
└──────────────────────┬───────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────┐
│      Session & Runtime Loader                │
│  - 加载 Session                              │
│  - 加载最新 Runtime Snapshot                 │
│                                              │
│  ※ 当前快照 = 唯一事实来源                  │
└──────────────────────┬───────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────┐
│     Turn Orchestrator（流程控制中枢）         │
│                                              │
│  - turn_index 管理                           │
│  - 会话 status 判断                          │
│  - focus_customer 决策                       │
│                                              │
│  - 调用 Rule Engine 进行：                   │
│    · 提示词路由裁决                          │
│    · 写入权限判断                            │
│    · 状态推导                                │
└───────────────┬───────────────┬──────────────┘
                │               │
     （规则允许）│               │（由 status 决定）
                ▼               ▼
┌──────────────────────┐   ┌──────────────────────┐
│  Semantic Analyzer   │   │ Dialogue Generator   │
│  （语义提取模块）    │   │ （对话生成模块）     │
│                      │   │                      │
│  - 仅在规则允许时调用│   │  - 仅负责生成回复文本│
│  - 输出字段候选值    │   │  - 不感知 state/status│
│  - 不修改任何状态    │   │  - 不决定对话策略    │
│                      │   │                      │
│  ※ 使用 SEMANTIC    │   │  ※ 使用的提示词由    │
│    PROMPT            │   │    规则引擎裁决      │
└──────────────┬───────┘   └──────────────┬───────┘
               │                            │
               ▼                            ▼
┌──────────────────────────────────────────────┐
│          Rule Engine（唯一裁决者）            │
│                                              │
│  - 写入权限判断                              │
│  - pending_updates 管理                      │
│  - 客户 state 推导                           │
│  - 会话 status 推导                          │
│  - CONFIRMING 阶段字段回退                   │
│                                              │
│  ※ 提示词“用不用 / 用哪种”在此生效           │
└──────────────────────┬───────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────┐
│     Runtime Snapshot Persistence              │
│  - 每一轮 turn 写入完整运行态快照            │
│  - 不可修改，仅追加                          │
│  - 支持中断恢复 / 回放                       │
└──────────────────────┬───────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────┐
│            数据库（PostgreSQL）               │
│                                              │
│  - Session                                   │
│  - Dialog（运行态快照）                       │
│  - 客户 / 跟进主数据                          │
│                                              │
│  ※ OUTPUTTING 阶段：                         │
│    仅基于确认后的结构化数据                    |
|    对客户名和联系人名做归一处理                │
│    不再进入任何提示词或模型链路                │
└──────────────────────────────────────────────┘

```

- 语义提取结果不具备任何状态修改权，仅作为规则引擎输入。
- 在对话过程中，客户名和联系人名可能会有多种称呼，需要在 OUTPUTING 阶段做归一处理，具体方法见第 15 章节。

### 4.2 对话过程说明

1. 用户第一次打开飞书机器人时，飞书机器人会主动向用户介绍自己的能力。例如，我是你的销售助理，可以帮你梳理一天的客户跟进情况，并将其记录下来。
2. 用户打开一个新的对话（创建新对话）时，飞书机器人会主动引导用户复盘一天的客户跟进情况。例如，你好，和我聊聊一天的工作情况，今天联系了哪些客户，都有什么进展。
3. 用户打开一个已有的对话（加载对话）时，飞书机器人会主动引导用户继续之前未完成的话题。例如，你好，我们继续聊下 xxx 客户下一步的工作计划吧。
4. 接收到用户的对话内容后
  * 如果和客户跟进信息相关，大模型会提取需要的跟进信息（更新对话状态），并生成回复内容（根据更新后的对话状态），进行和用户下一步的会话；
  * 如果和客户跟进信息无关，大模型不会提取任何信息（不更新对话状态），并生成回复内容（跟进当前的对话状态），引导用户回到当前的话题上来。
5. 反复迭代步骤 4 ，直到收集到所有的客户跟进记录，最后飞书机器人会复述今天所有跟进工作，和用户确认了是否正确
  * 如果用户确认没有问题，就结束对话；
  * 如果用户指出某一客户的跟进情况有问题，或者需要补充，将回到步骤 4 。
6. 结束对话后，飞书机器人会对用户今天的工作进行鼓励和感谢。例如，工作辛苦了，感谢你一天的付出。
7. 不要期待用户在一开始就将今天跟进的所有客户名都告诉机器人，然后和机器人一个个进行复盘。因此在完成一个客户的跟进情况对话后，机器人需要主动追问用户是否有下一个客户。例如，好的，这个客户的情况就聊到这了，还有其他客户吗。
8. 对话一旦开始，只有两种情况可以结束：
  * 完成所有客户跟进情况的对话，并和用户确认没有问题，可以结束对话；
  * 无论对话进行到哪个阶段，用户主动要求结束对话，例如，用户说：“上次对话就到这里，我们聊聊今天的工作情况。”  
  除了这两种情况，即使用户的客户端和飞书服务端的会话断开（会话超时）时间很久，用户再次打开飞书机器人时，上次的对话（对话状态重新从数据库中加载）也会继续。

### 4.3 语义失败分级

L1 NONE：无关 → 不写、不改、不切换
L2 WEAK：模糊 → 不写，仅引导

---

## 5. 核心数据模型

### 5.1 会话模型（Session）

```json
{
  "session_id": "uuid",
  "user_id": "u123",
  "status": "COLLECTING | CONFIRMING | OUTPUTTING | EXIT",
  "created_at": "...",
  "ended_at": null
}

```

---

## 5.2 对话运行态模型（Runtime Conversation State）

### 5.2.1 模型定义

对话运行态模型用于描述**当前会话在某一时刻的唯一有效上下文状态**，是系统在对话过程中进行状态判断、字段写入决策及流程控制的唯一依据。

对话运行态模型不等同于业务事实，也不等同于原始对话记录，其核心职责是**承载“正在进行中的对话理解结果”**。

---

### 5.2.2 模型结构

```json
{
  "session_id": "string",
  "focus_customer_id": "string | null",
  "state": "CUSTOMER_NAME | FOLLOW_METHOD | FOLLOW_CONTENT | FOLLOW_GOAL | FOLLOW_RESULT | NEXT_PLAN | COMPLETE",
  "status": "COLLECTING | CONFIRMING | OUTPUTTING | EXIT",
  "pending_updates": {
    "<field_name>": "<field_value>"
  }
}
```

---

### 5.2.3 字段说明

#### 1. session_id

- 当前对话会话的唯一标识。
- 用于将运行态模型与 session 级别流程控制进行绑定。

---

#### 2. focus_customer_id

- 表示当前对话轮次中**被聚焦处理的客户对象**。
- 在多客户场景下用于限定字段写入目标。
- 允许为空（`null`），表示当前轮次不针对单一客户进行操作。

---

#### 3. state（客户状态）

- 表示当前 `focus_customer` 所处的**信息收集状态**。
- `state` 决定：
  - 当前轮次**允许写入的唯一业务字段**；
  - 状态推进的合法顺序。
- `state` 为字符串枚举值，合法取值范围如下：

```text
CUSTOMER_NAME
FOLLOW_METHOD
FOLLOW_CONTENT
FOLLOW_GOAL
FOLLOW_RESULT
NEXT_PLAN
COMPLETE
```

---

#### 4. status（会话阶段）

- 表示当前会话所处的**整体交互阶段**。
- `status` 决定对话行为模式，但不直接影响字段写入顺序。
- `status` 为字符串枚举值，合法取值范围如下：

```text
COLLECTING
CONFIRMING
OUTPUTTING
EXIT
```

---

#### 5. pending_updates（暂存字段集合）

- 用于存放**已被模型理解，但尚未达到写入时机的结构化字段值**。
- 该结构以字段名为 key，对应字段解析值为 value。
- `pending_updates` 中的数据：
  - 不属于业务事实；
  - 不参与状态推导；
  - 不可直接写入客户主记录；
  - 对于 follow_time 的默认取值，系统应以客户首次成为 focus_customer 的对话轮次时间 作为时间锚点。该时间不需要显式存储为运行态字段，可由对话记录表推导获得。

---

### 5.2.4 核心行为与约束规则

#### 5.2.4.1 唯一写入原则

1. 在任一对话轮次中：
  - 系统 **仅允许写入一个业务字段**；
  - 该字段必须与当前 `state` 严格对应。
2. 任何不符合当前 `state` 的字段：
  - 不得直接写入客户主记录；
  - 必须进入 `pending_updates`。

---

#### 5.2.4.2 pending_updates 使用约束

1. `pending_updates` 仅允许存放：
  - 非当前 `state` 对应的字段；
  - 来自模型对用户输入的语义解析结果。
2. `pending_updates`：
  - 不得作为状态推进条件；
  - 不得影响 `state` 或 `status` 的直接变更。
3. 当系统状态推进至某字段对应的 `state` 时：
  - 若 `pending_updates` 中存在该字段；
  - 系统 **必须优先采用暂存值完成写入**。

---

#### 5.2.4.3 pending_updates 生命周期规则

1. 当某字段被正式写入客户主记录后：
  - 对应字段 **必须立即从 `pending_updates` 中移除**。
2. 当发生以下任一情况时，`pending_updates` 必须整体清空：
  - 会话状态进入 `EXIT`；
  - 会话被显式重置；
  - 在 `CONFIRMING` 阶段发生字段级重开，且暂存字段位于重开范围内。

---

#### 5.2.4.4 非顺序字段命中处理规则

1. 当用户输入命中**非当前 `state` 对应字段**时：
  - 系统不得跳过当前 `state`；
  - 系统不得提前推进 `state`。
2. 该类字段：
  - 允许按规则写入 `pending_updates`；
  - 不得直接写入客户主记录。
3. 对话层必须以自然语言方式承接用户输入，并引导用户回到当前 `state`。

---

#### 5.2.4.5 CONFIRMING 阶段的运行态行为

1. 在 `CONFIRMING` 阶段：
  - 允许用户修改任意已写入字段。
2. 当某字段被修改时：
  - 对话流程必须回到 `COLLECTING` 阶段，以便以收集阶段方式承接修改；
  - 清空并重开被修改字段及其后序字段；
  - 修改完成后，当全部客户再次 COMPLETE 时，直接回到 `CONFIRMING`（不经过 ASKING_OTHER_CUSTOMERS）。
3. 系统运行态：
  - `state` 必须回退至被修改字段对应状态；
  - `status` 先切换至 `COLLECTING`，待信息补全后切换回 `CONFIRMING`。
4. 与被清空字段相关的 `pending_updates` 必须同步失效。

---

#### 5.2.4.6 CUSTOMER_NAME 状态的对话行为约束

当运行态中 `customer_name = null`，且 state = CUSTOMER_NAME 时：

1. CUSTOMER_NAME 表示“当前尚未明确某一个具体客户”，而非“必须立即向用户询问客户名称”。
2. 在该状态下：

- 对话层的首要目标是引导用户复盘工作内容，而不是直接索要客户名称；
- 系统应允许用户先描述：
  - 做了什么事情
  - 联系了哪些人
  - 遇到了什么情况
   而客户名称可以在叙述过程中自然出现。

1. 仅当满足以下任一条件时，系统才应主动引导用户明确客户名称：

- 用户已经描述了明确的跟进行为，但对象仍不清晰；
- 系统需要在多个潜在客户之间做区分，但无法继续推进对话；
- 用户明确表示要“开始记录某个客户的跟进”。

1. 在 CUSTOMER_NAME 状态下：

- 不得使用“请提供客户名”“这次跟进的客户是谁”等填表式提问；
- 所有引导必须表现为顺着用户复盘叙述的自然追问。

---

### 5.2.5 持久化与恢复原则

1. 对话运行态模型属于**可恢复运行态**：
  - 允许在会话中断或系统重启后恢复；
  - 不等同于业务事实。
2. `pending_updates`：
  - 仅允许作为运行态快照的一部分进行持久化；
  - 不得拆分为独立业务表；
  - 不得参与历史统计或分析。

---

### 5.2.6 模型定位总结

> 对话运行态模型是连接“自然语言输入”与“结构化业务事实”的中间层，
> 其职责是**暂存、约束、顺序化**用户表达，
> 并确保所有业务状态变化均可被确定性地回放与验证。

---

## 6. 客户跟进状态引擎（核心）

### 6.1 状态枚举（固定不可扩展）

```
CUSTOMER_NAME
FOLLOW_METHOD
FOLLOW_CONTENT
FOLLOW_GOAL
FOLLOW_RESULT
NEXT_PLAN
COMPLETE

```

---

### 6.2 状态推导规则（唯一合法规则）

> **状态表示“当前仍需收集的字段”**

```text
IF customer_name == null        → CUSTOMER_NAME
ELSE IF follow_method == null  → FOLLOW_METHOD
ELSE IF follow_content == null → FOLLOW_CONTENT
ELSE IF follow_goal == null    → FOLLOW_GOAL
ELSE IF follow_result == null  → FOLLOW_RESULT
ELSE IF next_plan == null      → NEXT_PLAN
ELSE                           → COMPLETE

```

- 状态机用于描述“在当前客户上下文中，尚未被明确表达的信息点”，而非用于强制用户按顺序提供信息。
  - 在真实对话过程中，用户可能：
  - 跳跃表达多个字段
  - 回溯补充前序信息
  - 在不同客户之间来回切换
  - 状态机的职责是约束写入顺序，而不是约束对话顺序。
- risk：
  - risk 不参与状态推导
  - risk 不作为 state 枚举的一部分
  - risk 仅允许在以下条件下直接写入客户主记录：
    - semantic_relevance = STRONG
    - 当前 state ∈ {FOLLOW_RESULT, NEXT_PLAN}
  - risk 不进入 pending_updates
  - 在 CONFIRMING 阶段允许任意修改
- contact_person：
  - 仅在存在 focus_customer 时允许写入
  - 不影响客户状态
  - 可在任意阶段补充或修正

---

### 6.3 状态原则

- 在 COLLECTING 阶段，state 不允许回退
- 在 CONFIRMING 阶段，允许 state 按字段顺序回退
- 每次用户输入后，state 均由规则引擎基于当前数据重新计算
- state 回退仅用于字段重写，不代表会话阶段回退

---

### 6.3 focus_customer 选择规则（确定性）

优先级顺序：

1. 本轮用户明确点名的客户
2. 上一轮 focus_customer 且未 COMPLETE
3. state 顺序最靠前的客户
4. 最近被更新字段的客户

补充规则：

- 在 CONFIRMING 阶段，focus_customer 仅在用户显式点名时才允许变更
- 否则不执行自动 focus 选择规则

**单轮只允许一个 focus_customer**

---

## 7. 会话阶段状态机

### 7.1 阶段枚举

```
COLLECTING   信息收集
CONFIRMING   用户确认
OUTPUTTING   输出结果
EXIT         会话结束

```

---

### 7.2 阶段流转规则（每聊完一个客户即确认落库）

```text
存在任一客户 state ≠ COMPLETE     → COLLECTING
全部客户 state = COMPLETE         → CONFIRMING（仅当前客户）
用户确认                          → 落库该客户，若还有待确认客户则 CONFIRMING，否则 ASKING_OTHER_CUSTOMERS
ASKING_OTHER_CUSTOMERS 用户说没了 → OUTPUTTING（归一与收尾）
输出完成                          → EXIT

```

---

## 8. 输入相关性与写入权限机制

### 8.1 语义相关性（LLM 输出）

```
semantic_relevance = STRONG | WEAK | NONE

```

---

### 8.2 写入权限（规则引擎）

```text
IF semantic_relevance == STRONG AND 当前 state 对应字段
  → 允许写入
ELSE
  → 禁止写入，仅生成引导回复

```

---

### 8.3 对话输入吸收与状态写入规则

为同时满足自然对话体验与状态机可回放、可推导的工程约束，系统对单轮用户输入的处理，遵循以下统一规则。

---

#### 8.3.1 单轮多字段吸收规则（主写入 + 暂存机制）

1. 系统允许在**单轮用户输入中识别多个结构化字段**。
2. 在单轮处理中：
  - **仅允许将一个字段写入客户主记录**；
  - 该字段必须是**当前 state 对应的目标字段**（主写入字段）。
3. 对于同一轮输入中识别出的**其它非当前 state 字段**：
  - 不得写入客户主记录；
  - 必须写入运行态中的 `pending_updates` 暂存结构。
4. `pending_updates`：
  - 仅用于临时保存尚未到达写入时机的字段值；
  - 不参与状态推导；
  - 不作为业务事实持久化存储。

---

#### 8.3.2 暂存字段自动承接规则

1. 当系统状态推进至某一字段对应的 state 时：
  - 若 `pending_updates` 中存在该字段的值；
  - 系统 **必须优先采用暂存值完成写入**；
  - 不得再次向用户重复询问同一字段。
2. 在字段被正式写入主记录后：
  - 对应字段 **必须从 `pending_updates` 中移除**。
3. 若用户在正式写入前对暂存字段进行修正：
  - 系统 **必须以最新输入覆盖原暂存值**。

---

### 8.3.3 非当前状态字段命中处理规则（顺序约束）

1. 当用户输入命中**非当前 state 对应字段**时：
  - 系统 **不得跳过当前 state**；
  - 系统 **不得提前推进状态**。
2. 该类信息：
  - 允许按 8.3.1 规则写入 `pending_updates`；
  - 不得直接写入客户主记录。
3. 系统在对话层应以自然语言方式：
  - 承认用户表达内容；
  - 引导用户回到当前 state 所需信息。

---

### 8.3.4 CONFIRMING 阶段字段修改与局部重开规则

1. 在 `CONFIRMING` 阶段：
  - 允许用户对任意已写入字段提出修改。
2. 当某一字段被修改时：
  - 对话流程 **必须回到 COLLECTING 阶段**，以便以收集阶段的方式承接修改并补全可能受影响的后续字段；
  - 清空并重开：被修改字段以及其在状态顺序中的后续字段；
  - 修改完成后，当全部客户再次 state = COMPLETE 时，**必须直接回到 CONFIRMING 阶段**，重新呈现完整摘要供用户确认（不经过 ASKING_OTHER_CUSTOMERS）。
3. 系统状态：
  - 必须回退至被修改字段对应的 state；
  - 阶段（status）先切换至 `COLLECTING`，待信息补全后切换回 `CONFIRMING`。
4. 被清空字段对应的暂存信息（如存在）必须同步失效。

---

### 8.3.5 CONFIRMING 阶段的 focus_customer 行为规则

1. 在 `CONFIRMING` 阶段：
  - 系统默认以**整体复述与整体确认**为主要交互方式；
  - 不主动切换或强调 `focus_customer`。
2. 当用户在确认阶段针对某一客户提出修改或异议时：
  - 系统 **必须临时将 `focus_customer` 切换至对应客户**；
  - 完成该客户相关字段的修正与确认。
3. 修正完成后：
  - 系统 **必须回到整体确认视角**；
  - `focus_customer` 不再作为对话主导因素。

---

## 9. 单轮请求完整逻辑流转

```text
接收输入
→ 加载运行态
→ turn_index +1
→ LLM 语义判断
→ 写入权限判断
→ 写入 / 放弃
→ 重算状态
→ 选 focus_customer
→ 生成对话
→ 持久化快照

```

---

## 10. LLM 提示词设计

### 10.1 对话提示词设计原则

在对话生成过程中，系统应遵循“历史驱动”的设计原则：

1. User Prompt 的核心输入应为：
  - 当前聚焦客户相关的历史对话内容；
  - 用户最新一轮的自然语言输入；
  - 必要的对话语境事实（如当前是否已明确聚焦客户）。
2. 系统不得在 User Prompt 中显式注入：
  - 字段缺失情况；
  - 状态机状态（state、stage 等）；
  - 待补充信息列表或任何“需要完成的任务描述”。
3. 对话生成模型应仅基于已有的历史对话语义，
  自然决定下一步对话内容和引导方向，
   而不基于系统对“信息是否完整”的判断来生成对话。
4. 当某一客户的跟进信息尚不完整时，
  模型通过自然追问、复盘式提问等方式引导用户补充叙事细节；
   系统再将这些叙事细节映射为结构化字段，
   而非由模型感知或补齐字段本身。
5. 对话中“缺失信息的补充”属于系统侧的状态判断结果，
  不应作为显式指令或目标暴露给对话生成模型。

---

### 10.2 收集阶段对话提示词

- 系统提示词

```text
你是一名帮助用户（销售）梳理工作内容的对话助手。
你的任务是通过自然、轻松、不打断思路的方式，陪用户把当天的客户跟进情况慢慢说清楚。
对话原则：
- 把用户当成正在复盘工作的同事；
- 允许用户跑题、发散和情绪化表达；
- 所有追问都必须像顺着话接，而不是提要求；
- 一次只聊清楚一个点；
- 永远避免让用户感觉在“填表”或“被纠正”。
对话过程硬约束（必须遵守）：
- 你正在参与的是一个“可中断、可恢复的连续对话过程”，不是一次性问答；
- 不要假设用户会一次性说清所有客户或所有信息；
- 当某一个客户的情况已经聊清楚时，你必须自然地追问是否还有其他客户；
- 对话只有在以下两种情况下才可以结束：
  1）用户确认所有客户跟进都没有问题；
  2）用户明确表示要结束本次对话；
- 任何情况下，都不要因为信息不完整而中断对话。
客户跟进信息包括：客户名称、联系人、联系方式、跟进时间、跟进方式、跟进内容、跟进目标、跟进结果、下一步计划。
你不需要输出任何结构化信息，只需要返回要对用户说的话。
```

- 用户提示词

```text
请生成下一句你要对用户说的话。
当前对话背景：
- 这是一次工作跟进的复盘对话；
- 允许信息不完整、顺序混乱；
- 重点是复盘发生了什么，而不是填写信息。

当前聚焦客户：
{focus_customer_name}

已知跟进情况摘要：
{summary}

用户刚刚说：
{user_input}

请你自然地继续这段对话。
```

---

### 10.3 确认阶段对话提示词

- 系统提示词

```text
你正处于 CONFIRMING（用户确认）阶段。
你的目标不是继续采集信息，而是：
- 用自然语言复述用户今天的全部客户跟进情况；
- 让用户判断“是否有不对或需要补充的地方”。

行为规则：
- 默认以整体复述为主，不逐字段追问；
- 不主动引入新问题；
- 如果用户指出某个客户或某一点有问题：
  1）先简要确认已理解用户的修改；
  2）必须重新完整复述修正后的全部客户跟进情况（含已修正的内容）；
  3）再次询问用户"请确认以上修正后的内容是否还有不准确或需要补充的地方"；
  4）不得在修正后直接追问、聊下一步计划等，必须完成重新确认后再继续；
- 修正完成后的"回到整体确认视角"意味着：重新呈现完整摘要并请求再次确认，而非直接进入后续话题。
```

- 用户提示词

```text
根据跟进记录和用户说的，生成下一句你要对用户说的话。可以加入风险建议。
客户跟进记录：{customer_follow_records}
用户刚才说：{user_input}
```

---

### 10.4 客户跟进行信息的总结提示词

- 系统提示词

```text
你是一个“对话叙事摘要器”。
你的任务是：将输入中提供的、已经确认的客户跟进事实，转换为自然、人类可读的复盘式文字摘要，用于后续对话生成。
核心原则（必须遵守）：
1. 你只能基于用户输入中明确给出的事实进行描述，不得推测、补充或引入任何新信息。
2. 输出中严禁出现：
   - 字段名
   - 状态名
   - 枚举值
   - 系统术语
   - 表结构或数据化表达
3. 不得使用任何系统视角语言，包括但不限于：“已记录”“系统中显示”“当前状态”“字段”等。
表达与结构要求：
1. 使用自然语言，像人写的工作复盘；
2. 每一条都是一个已经发生过的事实；
3. 使用无序列表（bullet points）；
4. 每条 1–2 句；
5. 总条目数控制在 3–6 条；
6. 不要输出标题、编号或额外说明。
禁止行为：
1. 不要解释事实的意义；
2. 不要给出建议或下一步动作；
3. 不要总结用户意图或态度变化。
```

- 用户提示词

```text
以下是某一客户已经确认过的跟进事实，请将其整理为可用于对话中的自然复盘摘要。

输入事实（JSON）：{customer_follow_records}
```

---

### 10.5 客户/联系人归一提示词

- 系统提示词

```text
你是一个【客户/联系人归一评分模块】，处于系统的【OUTPUTING 阶段】。你必须仅输出 JSON，不得包含任何额外文字。
你的职责被严格限制为：
只对“对话中出现的客户/联系人提及（mention）”与“系统原来的候选实体（candidate entities）”之间的关系进行【归一评分】，并输出结构化评分结果。
输出 JSON 格式：
每一个 mention × candidate_entity，输出一个对象：
{
  "mention_id": "string",
  "entity_id": "string | null",
  "normalization_score": number,
  "normalization_level": "high | medium | low | none",
  "evidence": {
    "name_match": number,
    "context": number,
    "attributes": number,
    "history": number
  }
}
规则（必须遵守）：
1. 你只能基于输入中明确提供的信息进行评分：
   - 不允许补充、猜测或发明任何客户、联系人或属性
   - 不允许创建新的 entity_id
2. 每一个 mention 都必须：
   - 与所有 candidate entities 分别计算评分
   - 允许一个 mention 对应多个评分结果
3. 你只能“评分 + 标记等级”，禁止输出任何：
   - 是否为同一客户 / 联系人的最终结论
   - 合并、确认、写入等业务决策性判断
   - 自然语言解释或推理过程
评分维度（必须逐项给分）：
总分 100 分，必须拆分为以下四项，不可缺失：
1）名称匹配度（0–40）
- 联系人全名完全一致：40
- 全名高度相似（别名 / 简繁 / 拼写差异）：30
- 历史已知简称或称呼：20
- 模糊或部分相似：10
- 未出现联系人全名时，该项最高不超过 20
2）对话上下文一致性（0–25）
- 同一对话线程连续指代：10
- 业务事项或跟进内容一致：10
- 时间窗口内连续出现：5
3）关联属性匹配（0–20）
- 所属公司 / 客户一致：10
- 职位或角色一致：5
- 历史跟进行为一致：5
4）历史绑定置信（0–15）
- 历史高置信绑定记录：15
- 历史中置信绑定记录：8
- 无历史记录：0
约束（不可违反）：
- 联系人全名明确不一致时，总分不得达到 80 分
- 不允许仅凭名称模糊相似或上下文推断给出高分
- 信息不足时，必须保守给分，不允许“补全式评分”
评分等级定义（仅用于标记）：
- score ≥ 80        → high
- 60 ≤ score < 80   → medium
- 40 ≤ score < 60   → low
- score < 40        → none

```

- 用户提示词
```text
对话上下文：
{dialog_context}

已抽取的客户/联系人提及：
{mentions_entity}

候选客户/联系人实体：
{candidate_entities}
```

---

### 10.5 语义提取提示词

- 系统提示词

```text
你是一个语义信息抽取模块。以 JSON 形式返回给系统使用。
你的任务是：从用户输入中，严格提取“用户明确表达”的客户跟进信息。
json 格式：
{
  "semantic_relevance": "STRONG | WEAK | NONE",
  "customer_ref": {
    "mentioned": true,
    "customer_name": "xxxx | null"
  },
  "field_updates": {
    "customer_name": null,
    "contact_name": null,
    "contact_role": null,
    "contact_phone": null,
    "follow_time": null,
    "follow_method": null,
    "follow_content": null,
    "follow_goal": null,
    "follow_result": null,
    "risk": null,
    "next_plan": null
  }
}
重要规则：
- 只提取用户明确说出口的信息
- 不允许推断、不允许补全、不允许改写含义
- 不确定的信息必须是 null
- 没有提及的字段必须省略或为 null
- follow_time 仅在用户明确表达时间信息时才允许返回，不允许以当前时间、对话时间等方式自动补全
- semantic_relevance 的判定应基于“是否存在至少一个字段可被确定性写入”
- 模糊字段必须以 null 返回，不得影响 semantic_relevance 的整体判断
- 只输出 JSON，不得输出任何解释性文字
对话过程相关规则：
- 用户的输入可能是情绪化、跑题或对话承接语句，这些都属于正常对话，不一定包含可写入信息；
- 如果用户输入的主要作用是“回应、确认、否定、情绪表达”，且没有新增明确事实信息，应返回 semantic_relevance = NONE；
- 在 CONFIRMING 阶段，只有当用户明确指出“某一字段内容有误或需要修改”时，才返回可写入字段。
```

- 用户提示词

```text
当前会话阶段：{stage}
当前聚焦客户：{focus_customer_name}
当前客户所需信息点：{expected_field}
用户原始输入：{user_input}
```

---

### 10.5 各阶段提示词

- COLLECTING：提取 / 引导
- CONFIRMING：自然语言复述
- OUTPUTTING：JSON 输出（仅基于已确认数据）

---

### 10.6 提示词路由机制（Prompt Routing by Rule Engine）

### 10.6.1 设计原则

1. 系统内**仅存在两类提示词**：
  - **语义提取提示词（Semantic Prompt）**
  - **对话生成提示词（Dialogue Prompt）**
2. OUTPUTTING 阶段不属于提示词体系，而是**系统输出流程**。
3. 提示词的选择权完全由**规则引擎裁决**，而非 LLM。
4. 任一轮对话中：
  - 同一类提示词最多调用一次；
  - 不允许提示词嵌套或循环调用。

---

### 10.6.2 提示词类型枚举（最终定义）


| 提示词类型                   | 使用模块   | 作用                 |
| ----------------------- | ------ | ------------------ |
| SEMANTIC_PROMPT         | 语义分析模块 | 提取用户明确表达的结构化信息     |
| DIALOGUE_COLLECT_PROMPT | 对话生成模块 | COLLECTING 阶段自然对话  |
| DIALOGUE_CONFIRM_PROMPT | 对话生成模块 | CONFIRMING 阶段复述与修正 |


**系统中不存在 OUTPUT_PROMPT。**

---

### 10.6.3 提示词路由总览（规则驱动）


| 当前会话 status | 是否调用 SEMANTIC_PROMPT | 使用的对话提示词                |
| ----------- | -------------------- | ----------------------- |
| COLLECTING  | 是（符合条件时）             | DIALOGUE_COLLECT_PROMPT |
| CONFIRMING  | 是（仅字段修改时）            | DIALOGUE_CONFIRM_PROMPT |
| OUTPUTTING  | 否                    | 不调用对话提示词                |
| EXIT        | 否                    | 不调用                     |


---

### 10.6.4 SEMANTIC_PROMPT 路由规则

```text
IF status ∈ {COLLECTING, CONFIRMING} AND user_input 非纯控制 / 纯确认 / 纯情绪
→ 调用 SEMANTIC_PROMPT
ELSE
→ 跳过语义提取
```

#### 明确禁止调用语义提取的场景

- “结束吧”
- “确认没问题”
- “就这样吧”
- 纯情绪、寒暄、附和语句

---

### 10.6.5 对话提示词路由规则

#### 10.6.5.1 COLLECTING 阶段

```text
IF status = COLLECTING
→ 使用 DIALOGUE_COLLECT_PROMPT
```

- 不关心本轮是否成功写入
- 不关心是否发生语义失败
- 目标始终是：**对话不中断**

---

#### 10.6.5.2 CONFIRMING 阶段

```text
IF status = CONFIRMING
→ 使用 DIALOGUE_CONFIRM_PROMPT
```

- 以整体复述为主
- 仅在用户指出问题时进入局部修正
- 不允许退回 COLLECTING 提示词

---

### 10.6.6 OUTPUTTING 阶段的处理方式

当：

```text
status = OUTPUTTING
```

系统行为：

1. 基于**已确认的结构化数据快照**
2. 生成：
  - 客户名和联系人名归一处理（见 10.7 ）
  - 基于归一处理，修改客户表，合并客户记录
  - 跟进记录表写入
  - 必要的 JSON / 系统输出
3. **不再调用任何提示词**
4. 不再接受新的自然语言输入

---

### 10.6.7 单轮 Turn 内的执行顺序（最终）

```text
（可选）SEMANTIC_PROMPT
        ↓
RULE ENGINE（唯一裁决）
        ↓
（可选其一）
DIALOGUE_COLLECT_PROMPT
或
DIALOGUE_CONFIRM_PROMPT
或
无（OUTPUTTING）
```

---

### 10.6.8 本设计的关键收益

1. OUTPUTTING 完全可脱离 LLM
2. 提示词体系边界清晰、可控
3. 不存在“隐性提示词”
4. 对话失败不影响结果输出

---

### 10.7 客户/联系人归一

### 10.7.1 设计目标

在 OUTPUTING 阶段，对模型在对话中识别到的 **客户 / 联系人实体**进行统一归一判断，并为每一个潜在归一结果计算 **归一置信评分（Normalization Score）**，用于：

* 判断多次提及的不同名称是否指向同一客户 / 联系人
* 为下游结构化输出（如客户跟进记录、CRM 写入）提供稳定且可解释的实体绑定依据
* 在低置信度情况下，触发澄清提示或延迟结构化写入，避免错误合并

关键：**评分可解释性 + 规则可控性 + 模型不可随意猜测**。

---

### 10.7.2 基本原则

1. **强锚点优先原则**
   联系人全名（或系统已登记的唯一标识）是最高优先级锚点，任何弱特征不得覆盖强锚点结论。

2. **证据累积而非单点判断**
   归一结论必须由多维证据累积评分产生，禁止仅凭一次相似命中即完成归一。

3. **输出阶段只做判断，不做发明**
   OUTPUTING 阶段仅基于对话中已出现的信息与系统已知实体，不允许模型补充不存在的客户 / 联系人信息。

4. **评分驱动行为，而非直接裁决**
   是否合并、是否确认、是否追问，由评分区间决定，而非单一阈值硬判断。

---

### 10.7.3 评分对象定义

OUTPUTING 阶段的评分对象为：

```
CandidateBinding = {
  mention_id,          // 本次输出中出现的客户/联系人提及
  candidate_entity_id, // 系统中已有的客户/联系人候选实体
  score,               // 归一评分
  evidence_breakdown   // 评分证据明细
}
```

每一次输出，允许一个 mention 对应 **多个候选实体评分结果**。

---

### 10.7.4 评分维度与权重设计

归一评分采用加权累积方式，满分为 100 分，各维度如下：

#### 1. 名称匹配度（Name Matching，最高 40 分）

| 子项          | 说明               | 分值  |
| ----------- | ---------------- | --- |
| 联系人全名完全一致   | 字符级完全一致          | +40 |
| 联系人全名高度相似   | 简繁 / 拼写差异 / 别名映射 | +30 |
| 常用简称 / 称呼命中 | 需在历史对话中出现过绑定关系   | +20 |
| 模糊相似（仅部分命中） | 仅作为弱信号           | +10 |

> 规则：
>
> * 未出现联系人全名时，该维度最高不超过 20 分
> * 不允许仅凭模糊相似直接归一

---

#### 2. 对话上下文一致性（Context Consistency，最高 25 分）

| 子项         | 说明                    | 分值  |
| ---------- | --------------------- | --- |
| 同一对话线程连续出现 | 同一 Dialog / Session 内 | +10 |
| 业务事件一致     | 跟进事项、阶段、产品一致          | +10 |
| 时间连续性      | 在短时间窗口内反复指代           | +5  |

---

#### 3. 关联属性匹配（Attribute Alignment，最高 20 分）

| 子项           | 说明              | 分值  |
| ------------ | --------------- | --- |
| 所属公司 / 客户名一致 | 明确提及或系统已知       | +10 |
| 职位 / 角色一致    | 如“采购负责人”“技术对接人” | +5  |
| 关联历史行为一致     | 历史跟进、会议、报价      | +5  |

---

#### 4. 历史绑定置信（Historical Confidence，最高 15 分）

| 子项       | 说明          | 分值  |
| -------- | ----------- | --- |
| 历史已高置信绑定 | 之前评分 ≥ 确认阈值 | +15 |
| 历史中置信绑定  | 之前评分 ≥ 观察阈值 | +8  |
| 无历史记录    | 不加分         | 0   |

---

### 10.7.5 评分区间与系统行为定义

| 评分区间  | 归一状态      | OUTPUTING 行为                    |
| ----- | --------- | ------------------------------- |
| ≥ 80  | **高置信归一** | 直接绑定为同一客户 / 联系人                 |
| 60–79 | **中置信归一** | 绑定但标记 `needs_confirmation=true` |
| 40–59 | **低置信候选** | 保留为候选，不做合并                      |
| < 40  | **不归一**   | 视为不同实体                          |

---

### 10.7.6 输出结构约束（强制）

OUTPUTING 阶段输出的每一个客户 / 联系人实体，必须包含：

```json
{
  "entity_id": "string | null",
  "normalization_score": number,
  "normalization_level": "high | medium | low | none",
  "evidence": {
    "name_match": number,
    "context": number,
    "attributes": number,
    "history": number
  }
}
```

禁止仅输出归一结论而不输出评分与证据拆解。

---

### 10.7.7 失败与边界处理规则

1. **多候选高分冲突**

   * 若存在两个候选实体评分均 ≥ 60，禁止自动归一
   * 必须输出多候选结果，由规则引擎或人工处理

2. **强锚点冲突**

   * 联系人全名明确不一致时，任何其他维度不得使评分 ≥ 80

3. **信息不足**

   * 当所有候选评分 < 60，系统不得强行输出 entity_id

---

### 10.7.8 与规则引擎的协作关系

* OUTPUTING 阶段 **只负责评分与标记**
* 是否写入主数据、是否触发澄清问题，由规则引擎基于评分区间统一决策
* 本评分方案为 **规则引擎的不可覆盖输入信号**

---

## 11. 数据库设计

### 11.1 设计原则

- 对话表：每 turn 一条，不可修改，最新一条 = 当前事实
- 跟进记录表：仅在 OUTPUTTING 阶段生成，不可修改
- 客户 / 联系人表为主数据来源
- 对话中信息仅在确认后写入主表
- 对话表中的 JSON 字段承载完整运行态快照（state + pending_updates）

---

### 11.2 表设计

- 用户表

  | 字段名          | 类型           | 是否为空     | 默认值   | 注释                             |
  | ------------ | ------------ | -------- | ----- | ------------------------------ |
  | id           | VARCHAR(255) | NOT NULL | -     | 用户（销售）唯一标识符，来和飞书的 userid 一致    |
  | name         | VARCHAR(255) | NOT NULL | -     |                                |
  | phone        | VARCHAR(255) | NULL     | -     | -                              |
  | status       | INTEGER      | NOT NULL | -     | 用户当前状态，0 在职/1 离职               |
  | lark_user_id | VARCHAR(255) | NOT NULL | -     | 飞书用户 ID                        |
  | start_lark   | TIMESTAMPTZ  | NOT NULL | -     | 用户第一次开始对话的时间（含时区），用于提示机器人是否发送自我介绍内容 |
  | created_at   | TIMESTAMP    | NOT NULL | -     | -                              |
  | updated_at   | TIMESTAMP    | NOT NULL | NOW() | -                              |

- 客户表

  | 字段名            | 类型           | 是否为空     | 默认值   | 注释            |
  | -------------- | ------------ | -------- | ----- | ------------- |
  | id             | UUID         | NOT NULL | -     | 客户唯一标识符       |
  | name           | VARCHAR(255) | NOT NULL | -     | -             |
  | contact_person | VARCHAR(255) | NULL     | -     | 联系人姓名         |
  | contact_phone  | VARCHAR(255) | NULL     | -     | 联系人电话         |
  | contact_role   | VARCHAR(255) | NULL     | -     | 联系人职务或在项目中的角色 |
  | created_at     | TIMESTAMP    | NOT NULL | -     | -             |
  | updated_at     | TIMESTAMP    | NOT NULL | NOW() | -             |

- 会话表

  | 字段名        | 类型           | 是否为空     | 默认值 | 注释                                          |
  | ---------- | ------------ | -------- | --- | ------------------------------------------- |
  | id         | UUID         | NOT NULL | -   | -                                           |
  | user_id    | VARCHAR(255) | NOT NULL | -   | 用户唯一标识符，来和飞书的 userid 一致                     |
  | status     | VARCHAR(255) | NOT NULL | -   | 会话阶段（COLLECTING/CONFIRMING/OUTPUTTING/EXIT） |
  | created_at | TIMESTAMP    | NOT NULL | -   | -                                           |
  | updated_at | TIMESTAMP    | NOT NULL | NOW() | -                                           |
  | ended_at   | TIMESTAMP    | NULL     | -   | -                                           |

- 对话表

  | 字段名                | 类型           | 是否为空     | 默认值   | 注释                                                                                            |
  | ------------------ | ------------ | -------- | ----- | --------------------------------------------------------------------------------------------- |
  | id                 | UUID         | NOT NULL | -     | -                                                                                             |
  | session_id         | UUID         | NOT NULL | -     | -                                                                                             |
  | state              | VARCHAR(255) | NOT NULL | -     | 对话状态（CUSTOMER_NAME/FOLLOW_METHOD/FOLLOW_CONTENT/FOLLOW_GOAL/FOLLOW_RESULT/NEXT_PLAN/COMPLETE） |
  | status             | VARCHAR(255) | NOT NULL | -     | 会话阶段（COLLECTING/CONFIRMING/OUTPUTTING/EXIT）                                                   |
  | turn_index         | INTEGER      | NOT NULL | -     | -                                                                                             |
  | focus_customer_id  | UUID         | NULL     | -     | -                                                                                             |
  | is_first_focus     | BOOLEAN      | NOT NULL | false | 由规则引擎在 focus_customer 首次命中时写 true，为 follow_time 的锚点                                           |
  | semantic_relevance | VARCHAR(50)  | NULL     | -     | -                                                                                             |
  | pending_updates    | JSONB        | NULL     | -     | 运行态暂存字段(客户名/联系人姓名/联系人角色职务/联系方式/跟进时间/跟进事项/方法/目标/结果/风险/下一步计划)                                   |
  | runtime_snapshot   | JSONB        | NOT NULL | -     | 运行态                                                                                           |
  | created_at         | TIMESTAMP    | NOT NULL | -     | -                                                                                             |
  | updated_at         | TIMESTAMP    | NOT NULL | NOW() | -                                                                                             |


UNIQUE (session_id, turn_index)

- 跟进记录表

  | 字段名            | 类型            | 是否为空     | 默认值   | 注释          |
  | -------------- | ------------- | -------- | ----- | ----------- |
  | id             | UUID          | NOT NULL | -     | -           |
  | user_id        | VARCHAR(255)  | NOT NULL | -     | 用户（销售）唯一标识符 |
  | customer_id    | UUID          | NOT NULL | -     | 客户唯一标识      |
  | customer_name  | VARCHAR(255)  | NOT NULL | -     | -           |
  | contact_person | VARCHAR(255)  | NULL     | -     | -           |
  | contact_phone  | VARCHAR(255)  | NULL     | -     | -           |
  | contact_role   | VARCHAR(255)  | NULL     | -     | -           |
  | follow_time    | TIMESTAMP     | NOT NULL | -     |             |
  | follow_method  | VARCHAR(255)  | NULL     | -     | -           |
  | follow_content | VARCHAR(2000) | NULL     | -     | -           |
  | follow_goal    | VARCHAR(2000) | NULL     | -     | -           |
  | follow_result  | VARCHAR(2000) | NULL     | -     | -           |
  | risk_content   | VARCHAR(2000) | NULL     | -     | -           |
  | next_plan      | VARCHAR(2000) | NULL     | -     | -           |
  | created_at     | TIMESTAMP     | NOT NULL | -     | -           |
  | updated_at     | TIMESTAMP     | NOT NULL | NOW() | -           |


---

## 11.3 对话表与规则引擎的读 / 写 / 快照时序说明

### 11.3.1 时序设计目标

在对话式销售日志录入系统中，每一轮用户输入（turn）都必须满足以下工程目标：

1. 规则引擎始终基于**确定且唯一的运行态输入**进行裁决；
2. 单轮 turn 内：
  - 业务字段写入行为可控；
  - 状态推进行为可推导；
3. 对话运行态在轮次结束时被**完整、不可变地冻结**，以支持：
  - 会话中断与恢复；
  - 历史回放与审计。

为此，Dialog 表在单轮 turn 中承担 **“运行态输入源 + 运行态输出快照”** 的双重角色，其读写顺序由规则引擎严格控制。

---

### 11.3.2 单轮 Turn 内的总体时序

在一次完整的用户输入处理过程中，Dialog 表与规则引擎的交互顺序如下：

```text
① 读取上一轮 Dialog 记录
② 构建当前运行态（Working Runtime）
③ 语义解析（可选）
④ 规则引擎裁决（唯一写入者）
⑤ 写入受控字段
⑥ 重算状态与聚焦客户
⑦ 生成运行态快照
⑧ 追加写入新的 Dialog 记录
```

上述步骤在单一事务或等价的顺序一致性保障下完成。

---

### 11.3.3 各步骤详细说明

#### 步骤 ①：读取上一轮 Dialog 记录

- 系统根据 `session_id` 读取：
  - `turn_index` 最大的一条 Dialog 记录；
- 该记录被视为：
  - 当前会话的**唯一有效运行态来源**；
  - 不允许同时读取或合并多条历史记录。

---

#### 步骤 ②：构建当前运行态（Working Runtime）

系统基于上一轮 Dialog 记录构建“可变工作态”，包含：

- `state`
- `status`
- `focus_customer_id`
- `pending_updates`

该工作态仅存在于内存中，用于本轮规则判断，**不直接等同于持久化数据**。

---

#### 步骤 ③：语义解析（可选）

在满足提示词路由规则时：

- 调用语义解析模块；
- 得到候选字段值与 `semantic_relevance`；
- 所有解析结果：
  - 不得直接写入任何数据库表；
  - 仅作为规则引擎的输入参数。

---

#### 步骤 ④：规则引擎裁决（唯一写入者）

规则引擎基于以下输入进行裁决：

- 当前 Working Runtime；
- 语义解析输出（如存在）；
- 会话阶段（status）与状态机规则。

规则引擎在本步骤中**唯一合法地决定**：

- 是否允许字段写入；
- 写入目标字段；
- 是否写入 `pending_updates`；
- 是否发生状态推进或回退；
- 是否切换 `focus_customer`。

---

#### 步骤 ⑤：写入受控字段

根据规则引擎裁决结果：

- **至多一个字段**被写入客户主记录或跟进记录；
- 非当前 `state` 对应字段：
  - 按规则写入 `pending_updates`；
- 已完成写入的字段：
  - 必须立即从 `pending_updates` 中移除；
- 未满足写入条件的字段：
  - 被显式丢弃或保留于运行态中，不产生持久化副作用。

---

#### 步骤 ⑥：重算状态与聚焦客户

字段写入完成后，规则引擎：

- 基于最新业务数据重新计算：
  - 当前客户的 `state`；
  - 会话整体 `status`；
- 按既定优先级规则，确定下一轮的 `focus_customer_id`。

此步骤完成后，**当前轮次的运行态逻辑结果已完全确定**。

---

#### 步骤 ⑦：生成运行态快照（Runtime Snapshot）

规则引擎基于当前 Working Runtime 生成不可变快照对象：

```json
{
  "state": "...",
  "status": "...",
  "focus_customer_id": "...",
  "pending_updates": { ... }
}
```

该快照用于描述：

> **“在本轮对话处理完成后，系统认定的完整运行态”**

快照内容不参与后续规则判断，仅用于持久化与回放。

---

#### 步骤 ⑧：追加写入新的 Dialog 记录

系统以追加方式写入一条新的 Dialog 记录，包含：

- 新的 `turn_index`
- 当前 `state`
- 当前 `status`
- 当前 `focus_customer_id`
- 当前 `semantic_relevance`
- 当前 `pending_updates`
- 当前 `runtime_snapshot`
- `created_at`

写入完成后：

- 本轮 turn 结束；
- 新写入的 Dialog 记录成为下一轮的唯一运行态来源。

---

### 11.3.4 关键不变量说明

在任意时刻，系统必须保证：

1. **规则引擎是唯一能够修改运行态的组件**；
2. Dialog 表中：
  - 最新一条记录 = 当前会话唯一事实；
3. `runtime_snapshot`：
  - 只写不改；
  - 不参与规则裁决；
4. 任一 turn 的运行态变化：
  - 必须可由前一条 Dialog 记录 + 本轮输入确定性推导。

---

### 11.3.5 设计收益总结

通过上述读 / 写 / 快照时序设计：

- 对话运行态具备完整可回放链路；
- 单轮写入行为被严格约束，避免隐性状态漂移；
- 技术失败补偿与历史审计具备可靠依据；
- 系统整体行为从“依赖约定”升级为“依赖确定性规则”。

---

## 12. 并发与一致性策略

- Session 级乐观锁（updated_at）
- 单 Session 同时只允许一个写入源
- 冲突时返回“会话已更新，请重试”

---

## 13. 异常与边界处理


| 场景           | 行为              |
| ------------ | --------------- |
| 跑题           | 不写状态，仅引导        |
| 用户纠正         | 覆盖字段，重算         |
| LLM 异常       | 保持原状态           |
| 会话超时 / 客户端断开 | 不改变会话状态，仅持久化运行态 |
| 用户再次进入       | 从数据库加载运行态，继续对话  |
| 用户显式结束       | 进入 EXIT         |


- 会话的生命周期由用户意图决定，而非技术连接状态。
- 超时仅表示连接中断，不构成对话结束。

---

## 14. 测试策略

### 14.1 单元测试

- 状态推导
- focus_customer 选择

### 14.2 场景测试

- 多客户交叉输入
- 跑题 / 情绪输入
- 字段反复修正

### 14.3 并发测试

- 多端写入同一 Session

---

## 15. 系统最终定位

> **一个规则驱动、状态可控、LLM 辅助执行的对话式业务系统**

---

